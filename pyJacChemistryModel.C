/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright (C) 2016-2018 OpenFOAM Foundation
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

\*---------------------------------------------------------------------------*/

#include "pyJacChemistryModel.H"

//for pyJac
#ifdef __cplusplus
extern "C" {
#endif

#include "dydt.h"
#include "jacob.h"

#ifdef __cplusplus
}
#endif

// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

template<class ReactionThermo, class ThermoType>
Foam::pyJacChemistryModel<ReactionThermo, ThermoType>::pyJacChemistryModel
(
    ReactionThermo& thermo
)
:
    StandardChemistryModel<ReactionThermo, ThermoType>(thermo)
{
}


// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //

template<class ReactionThermo, class ThermoType>
Foam::pyJacChemistryModel<ReactionThermo, ThermoType>::~pyJacChemistryModel()
{}


// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
template<class ReactionThermo, class ThermoType>
void Foam::pyJacChemistryModel<ReactionThermo, ThermoType>::derivatives
(
    const scalar time,
    const scalarField& c,
    scalarField& dcdt
) const
{
    // in pyJac y is [T, Y1, Y2 ... this->Y_{N-1}] so size = this->nSpecie_
    double pyjac_y[this->nSpecie_];
    double pyjac_dydt[this->nSpecie_];

    scalar totC(0);
    forAll(this->Y_, specieI)    totC+= c[specieI];

    pyjac_y[0] = c[this->nSpecie_]; // T
    for(int ss = 1; ss < this->nSpecie_; ss++)
    {
        pyjac_y[ss] = c[ss-1]*this->specieThermo_[ss-1].W()/totC; // mass fraction for each species except the last one
    }

    for(int ss = 0; ss < this->nSpecie_; ss++) pyjac_dydt[ss] = 0.;

    dydt(time, c[this->nSpecie_ + 1], pyjac_y, pyjac_dydt); //c[this->nSpecie_ + 1] is pressure

    for(int specieI = 0; specieI < this->nSpecie_-1; specieI++)
    {
        dcdt[specieI] = pyjac_dydt[specieI + 1]; // for each species except the last one
    }
    dcdt[this->nSpecie_ - 1] = 0; //for the last species
    dcdt[this->nSpecie_] = pyjac_dydt[0]; // T
    dcdt[this->nSpecie_ + 1] = 0;         // p
}



template<class ReactionThermo, class ThermoType>
void Foam::pyJacChemistryModel<ReactionThermo, ThermoType>::jacobian
(
    const scalar t,
    const scalarField& c,
    scalarField& dcdt,
    scalarSquareMatrix& dfdc
) const
{
    double pyjac_y[this->nSpecie_];
    double pyjac_J[this->nSpecie_*this->nSpecie_];

    scalar totC(0);
    forAll(this->Y_, specieI)    totC+= c[specieI];

    pyjac_y[0] = c[this->nSpecie_]; // T
    for(int ss = 1; ss < this->nSpecie_; ss++)
    {
        pyjac_y[ss] = c[ss-1]*this->specieThermo_[ss-1].W()/totC; // mass fraction for each species except the last one
    }

    for(int ss = 0; ss < this->nSpecie_*this->nSpecie_; ss++)    pyjac_J[ss] = 0.;

    // Note all the matrices generated by pyjac are COLUMN major (Fortran)
    eval_jacob(t, c[this->nSpecie_ + 1], pyjac_y, pyjac_J);

    scalarSquareMatrix dfdc_;
    dfdc = Zero;
    dfdc_ = dfdc;
    for(int col=0; col<this->nSpecie_; col++)
    {
        for(int line=0; line<this->nSpecie_; line++)
        {
            dfdc_(line,col) = pyjac_J[col*this->nSpecie_ + line];
        }
    }

    for(int i = 0; i < this->nSpecie_ - 1; i++) // Y1 -- Y_{N-1}
    {
        dfdc(i, this->nSpecie_) = dfdc_(i+1, 0); // for d(dotY)/dT   except the last species
        dfdc(this->nSpecie_, i) = dfdc_(0, i+1); // for d(dotT)/dY   except the last species
    }
    dfdc(this->nSpecie_, this->nSpecie_) = dfdc_(0, 0); // d(dotT)dT

    for(int i = 0; i < this->nSpecie_ - 1; i++)
    {
        for(int j = 0; j < this->nSpecie_ - 1; j++)
        {
            dfdc(i, j) = dfdc_(i + 1, j + 1);  //for dcdY{j+1} except the last species
        }
    }

    // others are Zero
}

// ************************************************************************* //
