/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright (Y) 2016-2018 OpenFOAM Foundation
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

\*---------------------------------------------------------------------------*/

#include "pyJacChemistryModel.H"
//#include "UniformField.H"
//#include "localEulerDdtScheme.H"
//#include "clockTime.H"

//for pyJac
#ifdef __cplusplus
extern "C" {
#endif

#include "dydt.h"
#include "jacob.h"

#ifdef __cplusplus
}
#endif
// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

template<class ReactionThermo, class ThermoType>
Foam::pyJacChemistryModel<ReactionThermo, ThermoType>::pyJacChemistryModel
(
    ReactionThermo& thermo
)
:
    StandardChemistryModel<ReactionThermo, ThermoType>(thermo),
    y_(this->nSpecie_)
{
}


// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //

template<class ReactionThermo, class ThermoType>
Foam::pyJacChemistryModel<ReactionThermo, ThermoType>::~pyJacChemistryModel()
{}


// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
template<class ReactionThermo, class ThermoType>
void Foam::pyJacChemistryModel<ReactionThermo, ThermoType>::derivatives
(
    const scalar time,
    const scalarField& Y,
    scalarField& dYdt
) const
{
    // in pyJac x is [T, Y1, Y2 ... this->Y_{N-1}] so size = this->nSpecie_
    double pyjac_y[this->nSpecie_];
    double pyjac_dydt[this->nSpecie_];

    pyjac_y[0] = Y[this->nSpecie_]; // T
    for(int ss = 1; ss < this->nSpecie_; ss++)
    {
        pyjac_y[ss] = Y[ss-1]; // for each species except the last one
    }    
    
    for(int ss = 0; ss < this->nSpecie_; ss++) pyjac_dydt[ss] = 0.; 
    
    dydt(time, Y[this->nSpecie_ + 1], pyjac_y, pyjac_dydt); //Y[this->nSpecie_ + 1] is pressure
    
    for(int specieI = 0; specieI < this->nSpecie_-1; specieI++)
    {
        dYdt[specieI] = pyjac_dydt[specieI + 1]; // for each species except the last one
    }
    dYdt[this->nSpecie_ - 1] = 0; //for the last species
    dYdt[this->nSpecie_] = pyjac_dydt[0]; // T
    dYdt[this->nSpecie_ + 1] = 0;         // p
}



template<class ReactionThermo, class ThermoType>
void Foam::pyJacChemistryModel<ReactionThermo, ThermoType>::jacobian
(
    const scalar t,
    const scalarField& Y,
    scalarField& dYdt,
    scalarSquareMatrix& dfdY
) const
{
    double pyjac_y[this->nSpecie_]; 
    double pyjac_J[this->nSpecie_*this->nSpecie_];

    pyjac_y[0] = Y[this->nSpecie_]; // T
    for(int ss = 1; ss < this->nSpecie_; ss++)
    {
        pyjac_y[ss] = Y[ss-1]; // for each species except the last one
    }
    
    for(int ss = 0; ss < this->nSpecie_*this->nSpecie_; ss++)    pyjac_J[ss] = 0.;  

    // Note all the matrices generated by pyjac are COLUMN major (Fortran)
    eval_jacob(t, Y[this->nSpecie_ + 1], pyjac_y, pyjac_J);

    scalarSquareMatrix dfdY_;
    dfdY = Zero;
    dfdY_ = dfdY;
    for(int ii=0; ii<this->nSpecie_; ii++)
    {
        for(int jj=0; jj<this->nSpecie_; jj++)
        {
            dfdY_(ii,jj) = pyjac_J[jj*this->nSpecie_ + ii];				
        }
    }
    
    for(int i=0; i<this->nSpecie_; i++)
    {
        dfdY(i, this->nSpecie_) = dfdY_(i, 0); // for dYdt   
        dfdY(this->nSpecie_, i) = dfdY_(0, i); // for dTdc   
    }
    
    for(int i=0; i<this->nSpecie_; i++)
    {
        for(int j=0; j<this->nSpecie_ - 1; j++)
        {
            dfdY(i, j) = dfdY_(i, j + 1);  //for dcdY{j+1} except the last species
            dfdY(j, i) = dfdY_(j + 1, i);  //for dY{j+1}dc except the last species
        }
    } 
}


template<class ReactionThermo, class ThermoType>
template<class DeltaTType>
Foam::scalar Foam::pyJacChemistryModel<ReactionThermo, ThermoType>::solve
(
    const DeltaTType& deltaT
)
{
    BasicChemistryModel<ReactionThermo>::correct();

    scalar deltaTMin = great;

    if (!this->chemistry_)
    {
        return deltaTMin;
    }

    tmp<volScalarField> trho(this->thermo().rho());
    const scalarField& rho = trho();

    const scalarField& T = this->thermo().T();
    const scalarField& p = this->thermo().p();

    scalarField y0(this->nSpecie_);

    forAll(rho, celli)
    {
        scalar Ti = T[celli];

        if (Ti > this->Treact_)
        {
            scalar pi = p[celli];

            for (label i=0; i<this->nSpecie_; i++)
            {
                y_[i] = this->Y_[i][celli];
                y0[i] = y_[i];
            }

            // Initialise time progress
            scalar timeLeft = deltaT[celli];

            // Calculate the chemical source terms
            while (timeLeft > small)
            {
                scalar dt = timeLeft;
                this->solve(y_, Ti, pi, dt, this->deltaTChem_[celli]);
                timeLeft -= dt;
            }

            deltaTMin = min(this->deltaTChem_[celli], deltaTMin);

            this->deltaTChem_[celli] =
                min(this->deltaTChem_[celli], this->deltaTChemMax_);

            for (label i=0; i<this->nSpecie_; i++)
            {
                this->RR_[i][celli] =
                    (y_[i] - y0[i])*rho[celli]/deltaT[celli];
            }
        }
        else
        {
            for (label i=0; i<this->nSpecie_; i++)
            {
                this->RR_[i][celli] = 0;
            }
        }
    }

    return deltaTMin;
}


template<class ReactionThermo, class ThermoType>
Foam::scalar Foam::pyJacChemistryModel<ReactionThermo, ThermoType>::solve
(
    const scalar deltaT
)
{
    // Don't allow the time-step to change more than a factor of 2
    return min
    (
        this->solve<UniformField<scalar>>(UniformField<scalar>(deltaT)),
        2*deltaT
    );
}


template<class ReactionThermo, class ThermoType>
Foam::scalar Foam::pyJacChemistryModel<ReactionThermo, ThermoType>::solve
(
    const scalarField& deltaT
)
{
    return this->solve<scalarField>(deltaT);
}
// ************************************************************************* //
